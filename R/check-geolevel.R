#' @title compare_geolevels
#' @description
#' Checks if a geographical level sums up to the next granularity.
#'
#' @param dt data file, defaults to newcube
#' @param comparison which geographical levels are compared. Accepts combinations "FL" (Fylke-Land),
#' "KF" (Kommune-Fylke"), "BK" (Bydel-Kommune), and "OO" (Oslo kommune-fylke).
#' @return DT
#' @export
#' @examples
#' # compare_geolevels(data, "FL")
#' # compare_geolevels(data, "KF")
#' # compare_geolevels(data, "BK")
#' # compare_geolevels(data, "OO")
compare_geolevels <- function(dt = newcube,
                              comparison = c("FL", "LF", "KF", "FK", "BK", "KB", "OO"),
                              save= TRUE){
  comparison <- match.arg(comparison)
  comparison <- paste0(sort(strsplit(comparison, "")[[1]]), collapse = "")

  cubefile <- get_cubefilename(dt)
  savepath <- get_table_savefolder(get_cubename(dt))
  suffix <- paste0("compare_geolevel_", comparison)

  d <- data.table::copy(dt)
  groupdims <- grep("^GEO$", identify_coltypes(d)$dims.new, invert = T, value = T)
  teller_val <- select_teller_pri(names(d))
  if(is.na(teller_val)){
    cat("No sumTELLER(_uprikk) or TELLER(_uprikk) available, output not generated")
    return(invisible(NULL))
  }

  # Filter correct data
  d <- switch(comparison,
              FL = d[GEOniv %in% c("L", "F")],
              FK = d[GEOniv %in% c("F", "K")],
              BK = d[GEO %in% c(301, 1103, 4601, 5001) | GEOniv == "B"],
              OO = d[GEO %in% c(3, 301)])
  if(length(unique(d$GEOniv)) < 2) stop("Only 1 of the required geolevels present")
  d <- translate_geoniv(d)
  if(comparison == "OO") d[, GEOniv := paste0("Oslo ", GEOniv)]

  outcols <- switch(comparison,
                    FL = c("Land", "Fylke"),
                    FK = c("Fylke", "Kommune"),
                    BK = c("Kommune", "Bydel"),
                    OO = c("Oslo Fylke", "Oslo Kommune"))

  if(comparison == "BK"){
    add_kommune(d)
    groupdims <- c("KOMMUNE", groupdims)
  }

  by <- c("GEOniv", groupdims)

  # Estimate sum and diffs
  d <- d[, .("sum" = collapse::fsum(get(teller_val))), keyby = by]
  d <- data.table::dcast(d, ... ~ GEOniv, value.var = "sum")
  data.table::setcolorder(d, c(groupdims, outcols[1], outcols[2]))
  d[, let(Absolute = get(outcols[1])-get(outcols[2]),
          Relative = round(get(outcols[1])/get(outcols[2]), 3))]

  # Format output
  d[, (groupdims) := lapply(.SD, as.factor), .SDcols = groupdims]
  d[, (c(outcols, "Absolute")) := lapply(.SD, round, 0), .SDcols = c(outcols, "Absolute")]
  data.table::setorder(d, -Relative, na.last = T)
  if(any(d$Absolute[!is.na(d$Absolute)] < 0)) cat("For some rows, lower GEOlevel > higher GEOlevel, see rows where Absolute < 0!!")
  if(save) save_table_output(table = d, savepath = savepath, cubefile = cubefile, suffix = suffix)
  return(tab_output(d, nosearchcolumns = outcols))
}

#' @title unknown_bydel
#' @description
#' Estimate the proportion of unknown bydel, to check validity of the data.
#'
#' @param dt data file, defaults to newcube
#' @param crop Should the output table ble cropped to show a maximum of `maxrows`observations?
#' @param maxrows Max observations to show if `crop` = TRUE. Default = 4000. Will be divided equally between strata
#'
#' @return DT
#' @export
unknown_bydel <- function(dt = newcube,
                          crop = TRUE,
                          maxrows = 4000,
                          save = TRUE){
  d <- data.table::copy(dt)
  if(nrow(d[GEOniv == "B"]) == 0){
    cat("No data on bydel, no check performed")
    return(invisible(NULL))
  }

  cubefile <- get_cubefilename(dt)
  savepath <- get_table_savefolder(get_cubename(dt))
  suffix <- paste0("unknown_bydel")

  colinfo <- identify_coltypes(d)
  tellerval <- select_teller_pri(colinfo$vals.new)
  nevnerval <- select_nevner_pri(colinfo$vals.new)
  targets <- c(tellerval, nevnerval)
  targets <- targets[!is.na(targets)]
  d[, names(.SD) := lapply(.SD, as.numeric), .SDcols = targets]
  bydims <- grep("^GEO$", colinfo$dims.new, invert = T, value = T)

  if(length(targets) == 0){
    cat("No TELLER or NEVNER columns found in data, not possible to estimate unspecified bydel.\n")
    return(invisible(NULL))
  }

  # Filter and format data
  d <- d[GEO %in% c(301, 1103, 4601, 5001) | GEOniv == "B"]
  contains_bydel <- d[GEOniv == "B" & SPVFLAGG == 0, unique(AAR)]
  d <- d[AAR %in% contains_bydel]
  add_kommune(d)
  d <- d[, mget(c("KOMMUNE", "GEOniv", colinfo$dims.new, targets, "SPVFLAGG"))]
  d <- data.table::melt(d, measure.vars = targets, variable.name = "TARGET")
  d <- get_complete_strata(d, c("KOMMUNE", "TARGET", bydims), "missing", "value")

  if(nrow(d) < 1){
    cat("No complete strata, not possible to estimate unspecified bydel. Was bydelstart set to the correct year?\n")
    return(invisible(NULL))
  }

  # Estimate % unknown
  d <- d[, .(sum = sum(value, na.rm = T)), by = c("KOMMUNE", "GEOniv", "TARGET", bydims)]
  d <- data.table::dcast(d, ... ~ GEOniv, value.var = "sum")
  d[, UNKNOWN := round(100*(1 - B/K), 2)]
  d[B == 0 & K == 0, UNKNOWN := NA_real_]
  d <- d[order(-UNKNOWN)]
  data.table::setcolorder(d, c("KOMMUNE", bydims, "TARGET", "K", "B", "UNKNOWN"))
  data.table::setnames(d, c("K", "B", "UNKNOWN"), c("Kommune", "Bydel", "UNKNOWN, %"))

  # cat(paste0("Total number of strata with complete bydel (teller): ", nrow(d[TARGET == tellerval])))
  n_oslo <- nrow(d[TARGET == tellerval & KOMMUNE == "Oslo"])
  n_bergen <- nrow(d[TARGET == tellerval & KOMMUNE == "Bergen"])
  n_stavanger <- nrow(d[TARGET == tellerval & KOMMUNE == "Stavanger"])
  n_trondheim <- nrow(d[TARGET == tellerval & KOMMUNE == "Trondheim"])

  if(n_oslo == 0) cat(paste0("\nNo strata with complete bydel for Oslo!"))
  if(n_bergen == 0) cat(paste0("\nNo strata with complete bydel for Bergen!"))
  if(n_stavanger == 0) cat(paste0("\nNo strata with complete bydel for Stavanger!"))
  if(n_trondheim == 0) cat(paste0("\nNo strata with complete bydel for Trondheim!"))

  if(save) save_table_output(table = d, savepath = savepath, cubefile = cubefile, suffix = suffix)

  if(crop && nrow(d) > maxrows){
    combinations <- length(unique(d$KOMMUNE)) * length(unique(d$TARGET))
    n_obs_per_strata <- floor(maxrows / combinations)
    cat(paste0("\nTop ", n_obs_per_strata, " observations shown per MALTALL per KOMMUNE: "))
    d <- d[, .SD[1:n_obs_per_strata], by = c("KOMMUNE", "TARGET")]
  }

  tofactor <-which(!sapply(d, is.numeric))
  d[, (tofactor) := lapply(.SD, as.factor), .SDcols = tofactor]

  return(tab_output(d))
}

#' @keywords internal
#' @noRd
#' @description
#' Adds column KOMMUNE to identify Oslo, Stavanger, Bergen, and Trondheim for
#' grouping. Adds the column by reference, no need to overwrite object.
#' @examples
#' # add_commune(data)
add_kommune <- function(data){
  data[, let(KOMMUNE = NA_character_)]
  data[GEO %in% c(301, 1103, 4601, 5001) | GEOniv == "B" | GEOniv == "Bydel",
       let(KOMMUNE = data.table::fcase(grepl("^301", GEO), "Oslo",
                                       grepl("^1103", GEO), "Stavanger",
                                       grepl("^4601", GEO), "Bergen",
                                       grepl("^5001", GEO), "Trondheim"))]
  return(data)
}
